<!--
![Screenshot of a comment on a GitHub issue showing an image, added in the Markdown, of an Octocat smiling and raising a tentacle.](/01.%20basic-sql/images/go-back-arrow.png?raw=true)
-->



[![Go to Next Course](https://raster.shields.io/badge/%3C-E69138)](/03.%20plsql/README.md)
[![Go to Course Contents](https://raster.shields.io/badge/Previous_Course-E69138)](/03.%20plsql/README.md)
[![Go to Course Contents](https://raster.shields.io/badge/Course_Contents-6AA84F)](/03.%20plsql/README.md)
[![Go to Course Contents](https://raster.shields.io/badge/Next_Course-3D85C6)](/03.%20plsql/02.%20Flow%20Control%20(Conditional%20Statements).md)
[![Go to Next Course](https://raster.shields.io/badge/%3E-blue)](/03.%20plsql/02.%20Flow%20Control%20(Conditional%20Statements).md)


# 1. Getting started with PLSQL

- PL/SQL stands for Procedural Language extension of SQL.
- A combination of SQL along with the procedural features of
programming languages.
- Extends SQL by adding constructs found in procedural languages
like procedures, loops, variables, objects etc.
- PL/SQL program can consists of SQL and PL/SQL statements in
different blocks.
- A portable and high performance processing language.
- General syntax is based on that of ADA and Pascal programming
language.

<br>  

#### PL/SQL, How does it differ from SQL?

<br>  

![images/plsql-engine.png](/03.%20plsql/images/plsql-engine.png?raw=true)

<br>  

![images/plsql-sql-diff.png](/03.%20plsql/images/plsql-sql-diff.png?raw=true)

<br>  

#### Main Advantages of PL/SQL

- **Better Performance** due to block structure. In PL/SQL,SQL
statements can be grouped to blocks and the entire block
can be sent to database at one time for execution.
- **Less network traffic and improved response time**.
PL/SQL subprograms are compiled once and stored in
executable form. Thus, a single call can start a large job and
the work can be divided effectively.
- **Exception Handling**. Supports easy and effective exception handling method.
- **Portability**. Applications written in PL/SQL can run on any
operating system and platform where the database runs.
- **Integration with SQL**. Most of the SQL operations can be
done using PL/SQL and also supports SQL data types.
- PL/SQL supports both **Static SQL** and **Dynamic SQL**. Static SQL
supports DML and transaction control operations from
PL/SQL block. Dynamic SQL makes the application more
flexible and allows embedding DDL statements in PL/SQL
blocks and for creating run time queries.
- PL/SQL provides the ability to loop through records,
manipulating them one at a time whereas SQL does not.
- PL/SQL provides access to **predefined SQL packages**.
- Supports **Object Oriented Programming**.

<br>  

> [Further Reading](https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/overview.html#GUID-17166AA4-14DC-48A6-BE92-3FC758DAA940)

<br>  

### 1. PL/SQL Program Structure


- The basic unit of PL/SQL program is the **block**.
- PL/SQL programs are divided and written in logical blocks of
code.
- Each block consists of three sub parts
  - Declarations
  - Executable Commands
  - Exception Handling


<!-- 

![images/plsql-block1.png](/03.%20plsql/images/plsql-block1.png?raw=true)

-->

<br>  

#### PL/SQL Block Structure

![images/plsql-block2.png](/03.%20plsql/images/plsql-block2.png?raw=true)

<br>  


### 2. PL/SQL Data Types

- Each value in PL/SQL such as a constant, variable and parameter has a data type that determines the storage format, valid values, and allowed operations.

- PL/SQL has two kinds of data types:
    - scalar - store single values such as number, Boolean, character, and datetime
    - composite - that store multiple values, for example, record and collection

##### scalar data types

PL/SQL divides the scalar data types into four families:
- Number
- Boolean
- Character
- Datetime

<br>  

> [!NOTE]  
> A scalar data type may have subtypes. A subtype is a data type that is a subset of another data type, which is its base type.  
> A subtype further defines a base type by restricting the value or size of the base data type.
>  
> PL/SQL scalar data types include SQL data types and their own data types such as Boolean.


<br>  


#### Numeric data types
- The numeric data types represent real numbers, integers, and floating-point numbers. They are stored as ```NUMBER```, IEEE floating-point storage types (```BINARY_FLOAT``` and ```BINARY_DOUBLE```), and ```PLS_INTEGER```.

- The data types ```NUMBER```, ```BINARY_FLOAT```, and ```BINARY_DOUBLE``` are SQL data types.

- The ```PLS_INTEGER``` datatype is specific to PL/SQL. It represents signed 32 bits integers that range from ```-2,147,483,648``` to ```2,147,483,647```.

- Because ```PLS_INTEGER``` datatype uses hardware arithmetic, they are faster than NUMBER operations, which uses software arithmetic.

- In addition, ```PLS_INTEGER``` values require less storage than ```NUMBER```. Hence, you should always use ```PLS_INTEGER``` values for all calculations in its range to increase the efficiency of programs.

<br>  

##### The ```PLS_INTEGER``` datatype has the following predefined subtypes:

PLS_INTEGER subtypes|	Description
--- | ---
 NATURAL	| Represents nonnegative ``` PLS_INTEGER ``` values
 NATURALN	| 	Represents nonnegative ``` PLS_INTEGER ``` values with ```NOT NULL constraint```
 POSITIVE	| 	Represents positive ``` PLS_INTEGER ``` values
 POSITIVEN	| 	Represents positive ``` PLS_INTEGER ``` value with ```NOT NULL constraint```
 SIGNTYPE	| 	Represents three values -1, 0, or 1, which are useful for tri-state logic programming
 SIMPLE_INTEGER	| 	Represents ``` PLS_INTEGER ``` values with ```NOT NULL constraint```  
 
 
 <br>  
 
> [!NOTE]  
> PLS_INTEGER and BINARY_INTEGER data types are identical.

<br>  

#### Boolean data type
The ```BOOLEAN``` datatype has three data values: TRUE, FALSE, and NULL. Boolean values are typically used in control flow structures such as ```IF-THEN```, ```CASE```, and loop statements like ```LOOP```, ```FOR LOOP```, and ```WHILE LOOP```.  
<br>  
SQL does not have the ```BOOLEAN``` data type, therefore, you cannot:
- Assign a ```BOOLEAN``` value to a table column.
- Select the value from a table column into a ```BOOLEAN``` variable.
- Use a ```BOOLEAN``` value in an SQL function.
- Use a ```BOOLEAN``` expression in an SQL statement.
- Use a ```BOOLEAN``` value in the ```DBMS_OUTPUT.PUTLINE``` ```DBMS_OUTPUT.PUT``` subprograms.

<br>  

#### Character data types
The character data types represent alphanumeric text. PL/SQL uses the SQL character data types such as ```CHAR```, ```VARCHAR2```, ```LONG```, ```RAW```, ```LONG RAW```, ```ROWID```, and ```UROWID```.

 - ```CHAR(n)``` is a fixed-length character type whose length is from 1 to 32,767 bytes.
 - ```VARCHAR2(n)``` is varying length character data from 1 to 32,767 bytes.  
 
 <br>  
 
#### Datetime data types
The datetime data types represent dates, timestamps with or without time zones, and intervals. PL/SQL datetime data types are ```DATE```, ```TIMESTAMP```, ```TIMESTAMP WITH TIME ZONE```, ```TIMESTAMP WITH LOCAL TIME ZONE```, ```INTERVAL YEAR TO MONTH```, and ```INTERVAL DAY TO SECOND```.

<br>  

#### Data type synonyms
Data types have synonyms for compatibility with non-Oracle data sources such as IBM Db2, and SQL Server. It is not a good practice to use data type synonyms unless you are accessing a non-Oracle Database.

Data Type	| Synonyms
--- | ---
NUMBER	| 	DEC, DECIMAL, DOUBLE PRECISION, FLOAT, INTEGER, INT, NUMERIC, REAL, SMALLINT
CHAR	| 	CHARACTER, STRING
VARCHAR2	| 	VARCHAR
	

<br>  

### 3. PL/SQL Variables
- In PL/SQL, a variable is named storage location that stores a value of a particular data type.
- The value of the variable changes through the program. Before using a variable, you must declare it in the declaration section of a block.

> #### Declaring variables  

- A variable declaration always specifies the name and data type of the variable.
- For most data types, a variable declaration can also specify an initial value.
- The variable name must be a valid user-defined identifier.
- The data type can be any PL/SQL data type. The PL/SQL data types include the SQL data types. A data type is either scalar (without internal components) or composite (with internal components).

<br>  

##### Variable Declaration with NOT NULL Constraint
   In this example, the variable ```acct_id``` acquires the ```NOT NULL constraint```  explicitly, and the variables a, b, and c acquire it from their data types.  

```sql
DECLARE
  acct_id INTEGER(4) NOT NULL := 9999;
  a NATURALN                  := 9999;
  b POSITIVEN                 := 9999;
  c SIMPLE_INTEGER            := 9999;
BEGIN
  NULL;
END;
/
```
<br>  

##### Variables Initialized to NULL Values
```sql
DECLARE
  null_string  VARCHAR2(80) := TO_CHAR('');
  address      VARCHAR2(80);
  zip_code     VARCHAR2(80) := SUBSTR(address, 25, 0);
  name         VARCHAR2(80);
  valid        BOOLEAN      := (name != '');
BEGIN
  NULL;
END;
/
```
<br>  

##### Scalar Variable Declarations

```sql
DECLARE
  part_number       NUMBER(6);     -- SQL data type
  part_name         VARCHAR2(20);  -- SQL data type
  in_stock          BOOLEAN;       -- PL/SQL-only data type
  part_price        NUMBER(6,2);   -- SQL data type
  part_description  VARCHAR2(50);  -- SQL data type
BEGIN
  NULL;
END;
/
```
<br>  

<br>  


> #### Assigning Values to Variables

After declaring a variable, you can assign a value to it in these ways:
- Use the assignment statement to assign it the value of an expression.
- Use the ```SELECT INTO``` or ```FETCH``` statement to assign it a value from a table.
- Pass it to a subprogram as an ```OUT``` or ```IN OUT``` parameter, and then assign the value inside the subprogram.

<br>  

> [!NOTE]
> 
> The variable and the value must have compatible data types.  
> One data type is compatible with another data type if it can be implicitly converted to that type.

<br>  

##### Assigning Values to Variables with Assignment Statement

This example declares several variables (specifying initial values for some) and then uses assignment statements to assign the values of expressions to them.

```sql
DECLARE  -- You can assign initial values here
  wages          NUMBER;
  hours_worked   NUMBER := 40;
  hourly_salary  NUMBER := 22.50;
  bonus          NUMBER := 150;
  country        VARCHAR2(128);
  counter        NUMBER := 0;
  done           BOOLEAN;
  valid_id       BOOLEAN;
  emp_rec1       employees%ROWTYPE;
  emp_rec2       employees%ROWTYPE;
  TYPE commissions IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  comm_tab       commissions;
 
BEGIN  -- You can assign values here too
  wages := (hours_worked * hourly_salary) + bonus;
  country := 'France';
  country := UPPER('Canada');
  done := (counter > 100);
  valid_id := TRUE;
  emp_rec1.first_name := 'Antonio';
  emp_rec1.last_name := 'Ortiz';
  emp_rec1 := emp_rec2;
  comm_tab(5) := 20000 * 0.15;
END;
/
```

<br>  

##### Assigning Value to Variable with SELECT INTO Statement  
This example uses a ```SELECT INTO``` statement to assign to the variable bonus the value that is 10% of the salary of the employee whose employee_id is 100.


```sql
DECLARE
  bonus   NUMBER(8,2);
BEGIN
  SELECT salary * 0.10 INTO bonus
  FROM employees
  WHERE employee_id = 100;
END;

DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));
/

```
Result:
```
bonus = 2400
```

<br>  

##### Assigning Values to Variables as Parameters of a Subprogram
If you pass a variable to a subprogram as an OUT or IN OUT parameter, and the subprogram assigns a value to the parameter, the variable retains that value after the subprogram finishes running.

This example passes the variable new_sal to the procedure adjust_salary. The procedure assigns a value to the corresponding formal parameter, sal. Because sal is an IN OUT parameter, the variable new_sal retains the assigned value after the procedure finishes running.

```sql
DECLARE
  emp_salary  NUMBER(8,2);
 
  PROCEDURE adjust_salary (
    emp        NUMBER, 
    sal IN OUT NUMBER,
    adjustment NUMBER
  ) IS
  BEGIN
    sal := sal + adjustment;
  END;
 
BEGIN
  SELECT salary INTO emp_salary
  FROM employees
  WHERE employee_id = 100;
 
  DBMS_OUTPUT.PUT_LINE
   ('Before invoking procedure, emp_salary: ' || emp_salary);
 
  adjust_salary (100, emp_salary, 1000);
 
  DBMS_OUTPUT.PUT_LINE
   ('After invoking procedure, emp_salary: ' || emp_salary);
END;
/
 
```

Result:  

```
Before invoking procedure, emp_salary: 24000
After invoking procedure, emp_salary: 25000
```
<br>  

##### Assigning Values to BOOLEAN Variables  

The only values that you can assign to a ```BOOLEAN``` variable are ```TRUE```, ```FALSE```, and ```NULL```.

This example initializes the ```BOOLEAN``` variable done to NULL by default, assigns it the literal value ```FALSE```, compares it to the literal value ```TRUE```, and assigns it the value of a ```BOOLEAN``` expression.

```sql
DECLARE
  done    BOOLEAN;              -- Initial value is NULL by default
  counter NUMBER := 0;
BEGIN
  done := FALSE;                -- Assign literal value
  WHILE done != TRUE            -- Compare to literal value
    LOOP
      counter := counter + 1;
      done := (counter > 500);  -- Assign value of BOOLEAN expression
    END LOOP;
END;
/

```

### 4. PL/SQL Constants  
A constant holds a value that does not change. A constant declaration specifies the name, data type, and value of the constant and allocates storage for it. The declaration can also impose the NOT NULL constraint.

This example declares three constants with scalar data types.

```sql
DECLARE
  credit_limit     CONSTANT REAL  NOT NULL  := 5000.00;  -- SQL data type
  max_days_in_year CONSTANT INTEGER := 366;      -- SQL data type
  urban_legend     CONSTANT BOOLEAN := FALSE;    -- PL/SQL-only data type
BEGIN
  NULL;
END;
/
```

### 5. PL/SQL Comments  
The PL/SQL compiler ignores comments. Their purpose is to help other application developers understand your source text.

Typically, you use comments to describe the purpose and use of each code segment. You can also disable obsolete or unfinished pieces of code by turning them into comments.

##### Single-Line Comments
A single-line comment begins with -- and extends to the end of the line.  

<br>  

> [!CAUTION]
> 
> Do not put a single-line comment in a PL/SQL block to be processed dynamically by an Oracle Precompiler program.
> The Oracle Precompiler program ignores end-of-line characters, which means that a single-line comment ends when the block ends.

<br>  

This example has three single-line comments:   
```sql
DECLARE
  howmany     NUMBER;
  num_tables  NUMBER;
BEGIN
  -- Begin processing
  SELECT COUNT(*) INTO howmany
  FROM USER_OBJECTS
  WHERE OBJECT_TYPE = 'TABLE'; -- Check number of tables
  num_tables := howmany;       -- Compute another value
END;
/

```
<br>  

##### Multiline Comments
A multiline comment begins with /*, ends with */, and can span multiple lines.

You can use multiline comment delimiters to "comment out" sections of code. When doing so, be careful not to cause nested multiline comments. One multiline comment cannot contain another multiline comment. However, a multiline comment can contain a single-line comment.

For example, this causes a syntax error:

```sql
/*
  IF 2 + 2 = 4 THEN
    some_condition := TRUE;
  /* We expect this THEN to always be performed */
  END IF;
*/

```

<br>  

This does not cause a syntax error:  

```sql
/*
  IF 2 + 2 = 4 THEN
    some_condition := TRUE;
  -- We expect this THEN to always be performed
  END IF;
*/
```
<br>  

This example has two multiline comments:  

```sql
DECLARE
  some_condition  BOOLEAN;
  pi              NUMBER := 3.1415926;
  radius          NUMBER := 15;
  area            NUMBER;
BEGIN
  /* Perform some simple tests and assignments */
 
  IF 2 + 2 = 4 THEN
    some_condition := TRUE;
  /* We expect this THEN to always be performed */
  END IF;
 
  /* This line computes the area of a circle using pi,
  which is the ratio between the circumference and diameter.
  After the area is computed, the result is displayed. */
 
  area := pi * radius**2;
  DBMS_OUTPUT.PUT_LINE('The area is: ' || TO_CHAR(area));
END;
/
 ```

Result:

```
The area is: 706.858335
```
