# 2. Data Types and Constraints

### Character Data Types
Oracle Database has **three key character types**:

- varchar2
- char
- clob
```
You use these to store general purpose text.
```

#### Varchar2
This stores variable length text. You need to specify an upper limit for the size of these strings.  
In Oracle Database 11.2 and before, the maximum you can specify is 4,000 bytes.  
From 12.1 you can increase this length to 32,767.

<br>

#### Char
These store fixed-length strings. If the text you insert is shorter than the max length for the column, the database right pads it with spaces.
The maximum size of char is 2,000 bytes.  
<br>
> [!NOTE]
> Only use char if you need fixed-width data. In the vast majority of cases, you should use varchar2 for short strings.
<br>

#### Clob
If you need to store text larger than the upper limit of a varchar2, use a clob. This is a character large object.  
It can store data up to (4 gigabytes - 1) * (database block size). In a default Oracle Database installation this is 32Tb!

<br>

> [!IMPORTANT]
> The following statement creates a table with various character columns:


```sql
create table character_data (
  varchar_10_col   varchar2(10),
  varchar_4000_col varchar2(4000),
  char_10_col      char(10),
  clob_col         clob
);

select column_name, data_type, data_length
from   user_tab_columns
where  table_name = 'CHARACTER_DATA';
```
<br>

> [!NOTE]
> Each of these types also has an N variation; nchar, nvarchar2, and nclob. These store Unicode-only data.
> It's rare you'll use these data types.

<br>

### Numeric Data Types
The built-in numeric data types for Oracle Database are:

- number
- float
- binary_float
- binary_double
- ANSI Numeric Types
  
```
You use these to store numeric values, such as prices, weights, etc.
```


#### Number
This is the most common numeric data type. The format of it is:

number ( precision, scale )
The precision states the number of significant figures allowed. Scale determines the digits from the decimal point. The database rounds values that exceed the scale. <br> <br>


> ##### For example:

Value | Min Value |	Max Value
--- | --- | ---
number ( 3, 2 ) |	-9.99 |	9.99
number ( 3, -2 ) |	-99900 |	99900
number ( 5 ) |	-99999 |	99999
<br>

> [!NOTE]
> If you omit the precision and scale, the number defaults to the maximum range and precision.
<br>


#### Float
This is a subtype of number. You can use it to store floating-point numbers. But we recommend that you use binary_float or binary_double instead.


<br>

#### Binary_float & Binary_double
These are floating point numbers. They can have any number of digits after the decimal point.

Binary_float is a 32-bit, single-precision floating-point number. Binary_double is a 64-bit, double-precision floating-point. The limits for these data types are:

Value |	binary_float |	binary_double
--- | --- | ---
Maximum positive value |	3.40282E+38F |	1.79769313486231E+308
Minimum positive value |	1.17549E-38F |	2.22507485850720E-308

<br>

> [!NOTE]
> These also allow you to store the special values infinity and NaN (not a number).
<br>

#### ANSI Numeric Types
Oracle Database also supports ANSI numeric types, which map back to built-in types. 

> ##### For example:

integer => number(*, 0)  
real => float(63)

<br>

> [!IMPORTANT]
>  The following creates a table with various numeric data types:

```sql
create table numeric_data (
  number_3_sf_2_dp  number(3, 2),
  number_3_sf_2     number(3, -2),
  number_5_sf_0_dp  number(5, 0),
  integer_col       integer,
  float_col         float(10),
  real_col          real,
  binary_float_col  binary_float,
  binary_double_col binary_double
);

select column_name, data_type, data_length, data_precision, data_scale
from   user_tab_columns
where  table_name = 'NUMERIC_DATA';
```
<br>

> [!NOTE]
> The columns defined with ANSI types (integer_col & real_col) are mapped to the Oracle type.

<br>

### Datetime and Interval Data Types
Oracle Database has the following datetime data types:

- date
- timestamp
- timestamp with time zone
- timestamp with local time zone
```
You use these to store when events happened or are planned to happen.

Always use one of the above types to store datetime values. Not numeric or string types!
```

#### Date
Dates are granular to the second. These always include the time of day. There is no "day" data type which stores calendar dates with no time in Oracle Database.

You can specify date values with the keyword date, followed by text in the format YYYY-MM-DD.  


> For example the following is the date 14 Feb 2018:

```sql
date'2018-02-14'
```
This is a date with a time of midnight. If you need to state the time of day too, you need to use to_date. This takes the text of your date and a format mask.    


> For example, this returns the datetime 23 July 2018 9:00 AM:

```sql
to_date ( '2018-07-23 09:00 AM', 'YYYY-MM-DD HH:MI AM' )
```
When you store dates, the database converts them to an internal format. The client controls the display format.

<br>

#### Timestamp
If you need greater precision than dates, use timestamps. These can include up to nine digits of fractional seconds. The precision states how many fractional seconds the column stores. By default you get six digits (microseconds).

You can specify timestamp values like dates. Either use the timestamp keyword or to_timestamp with a format mask:

```sql
timestamp '2018-02-14 09:00:00.123'
to_timestamp ( '2018-07-23 09:00:00.123 AM', 'YYYY-MM-DD HH:MI:SS.FF AM' )
```
Timestamps have another advantage over dates. You can store time zone information in them. You can't store time zone details in a date.

A timestamp with time zone column stores values passed as-is. When you query a timestamp with time zone, the database returns the value you stored.

The database converts values in local time zones to its time zone. When you fetch these columns, the database returns it in the time zone of the session.

<br>

#### Time Intervals
You can store time durations with intervals. Oracle Database has two interval types: year to month and day to second.

You can add or subtract intervals from dates, timestamps or equivalent intervals. But the intervals are incompatible! You can't combine a day to second interval with a year to month one. This is because the number of days varies between months and years.

<br>

> [!IMPORTANT]
> The following creates a table with the various datetime data types:

```sql
create table datetime_data (
  date_col                      date,
  timestamp_with_3_frac_sec_col timestamp(3),
  timestamp_with_tz             timestamp with time zone,
  timestamp_with_local_tz       timestamp with local time zone,
  year_to_month_col             interval year to month,
  day_to_second_col             interval day to second
);

select column_name, data_type, data_length, data_precision, data_scale
from   user_tab_columns
where  table_name = 'DATETIME_DATA';
```

<br> <br />
### Binary Data Types
There are two key binary types: 

- raw 
- blob
  
```
You use binary data to store in its original format.

These are usually other files, such as graphics, sound, video or Word documents.
```

#### Raw
Like with character data, raw is for smaller items. You specify the maximum length of data for each column. It has a maximum limit of 2,000 bytes up to 11.2 and 32,767 from 12.1.

#### Blob
Blob stands for binary large object. As with clob, the maximum size you can store is (4 gigabytes - 1) * (database block size).

<br>

> [!IMPORTANT]
> The following creates a table with binary data type columns:

```sql
create table binary_data (
  raw_col  raw(1000),
  blob_col blob
);

select column_name, data_type, data_length, data_precision, data_scale
from   user_tab_columns
where  table_name = 'BINARY_DATA';
```

> [Original Source Link - Oracle Live SQL](https://livesql.oracle.com/apex/livesql/file/tutorial_FIMJZ2NPQ4AWTCE0B329BW3GX.html)  

> [Oracle Further Reading on Data Types](http://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=SQLRF0021)

<br> <br />
### Constraints
Use a constraint to define an integrity constraintâ€”a rule that restricts the values in a database.  
Oracle Database lets you create six types of constraints and lets you declare them in two ways.

The six types of integrity constraint are described briefly here:

- A **NOT NULL** constraint prohibits a database value from being null.

- A **UNIQUE** constraint prohibits multiple rows from having the same value in the same column or combination of columns but allows some values to be null.

- A **PRIMARY KEY** constraint combines a NOT NULL constraint and a unique constraint in a single declaration. That is, it prohibits multiple rows from having the same value in the same column or combination of columns and prohibits values from being null.

- A **FOREIGN KEY** constraint requires values in one table to match values in another table.

- A **CHECK** constraint requires a value in the database to comply with a specified condition.

- A REF column by definition references an object in another object type or in a relational table. A **REF** constraint lets you further describe the relationship between the REF column and the object it references.  

<br>

> You can define constraints syntactically in two ways:

- As part of the definition of an individual column or attribute. This is called **inline** specification.

- As part of the table definition. This is called **out-of-line** specification.

<br>

> [!NOTE]
> NOT NULL constraints must be declared inline. All other constraints can be declared either inline or out of line.

<br>

> Constraint clauses can appear in the following statements:

- CREATE TABLE (will be covered in Next Section)

- ALTER TABLE (will be covered in Next Section)



<br> <br />
#### NOT NULL Constraints
A NOT NULL constraint prohibits a column from containing nulls.  
The NULL keyword by itself does not actually define an integrity constraint, but you can specify it to explicitly permit a column to contain nulls.  
You must define NOT NULL and NULL using inline specification. If you specify neither NOT NULL nor NULL, then the default is NULL.

NOT NULL constraints are the only constraints you can specify inline on XMLType and VARRAY columns.

To satisfy a NOT NULL constraint, every row in the table must contain a value for the column.


> [!NOTE]
> Oracle Database does not index table rows in which all key columns are null except in the case of bitmap indexes.  
> Therefore, if you want an index on all rows of a table, then you must either specify NOT NULL constraints for at least one of the index key columns or create a bitmap index.

<br>

> ##### Restrictions on NOT NULL Constraints
- You cannot specify NULL or NOT NULL in a view constraint.
- You cannot specify NULL or NOT NULL for an attribute of an object. Instead, use a CHECK constraint with the IS [NOT] NULL condition.
